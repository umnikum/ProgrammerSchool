Правила игры:

Часть I. Суть игры

1.1) Есть большое пустое прямоугольное поле

1.2) На поле встречаются 2 команды соперников

1.3) Происходит сражение команд, выжившие - победители


Часть II. Персонажи

2.1) Каждый персонаж имеет аттрибуты
-Сила отвечает за урон персонажа
	урон = сила+1
-Ловкость за то, как часто персонаж ходит
	за 12 тиков персонаж ходит 12/(5-ловкость) раз(а)
-Интелект в пролёте xD
-Живучесть за здоровье
	здоровье = 2*живучесть
-Восприятние за дальность обзора
	радиус обзора = восприятие+1

2.2) Каждый персонаж обладает своими инструкциями
Инструкции прописаны в наследнике класса стратегия и выдаются по имени персонажа


Часть III. Ход

3.1) Каждый персонаж по очереди появления выбирает клетку на которую встанет

3.2) Можно вставать на пустую(ничего нет) клетку либо на клетку с живым противником

3.3) Если выбрана клетка с противником, то он получает урон. Если он слабее ходившего персонажа,
его откидывает в направлении движения ходившего персонажа, либо если это невозможно наносится 2ой урон,
ходивший персонаж встаёт на опустевшее место.


Часть IV. Команды

4.1) Команда может состоять из различных персонажей, ограниченных условием балланса.

4.2) Если команда OP, то балансировщик вам это скажет и не позволит начать раунд.
	Можно самим установить балланс в метоже Engine.spawn_teams() есть переменная max_score = 300


Часть V. Поведение

5.1) Класс Strategy уже имеет удобные методы, которые полезно использовать.
Ярким примером являются виртуальные методы patroll() и persue() состовляющие основу поведения
Также рекомендую пользоваться walk_around(direction) - обходить непредвиденное препядствие

5.2) Ваш класс должен публично наследоваться(class MyStrategy : public Strategy{};)
По умолчанию запускается virtual Coordinates choose_move()const, его или его части нужно переписать:
	Coordinates choose_move()const override без ключевого слова virtual, но со словом override в конце
В публичной части унаследовать конструктор using Strategy::Strategy;

5.3) Вам дан информационный класс GameState в переменной game_state, у него куча полезных методов:

	Character perspective()const - даёт вашего персонажа который сейчас ходит
	
	Containment check(const Coordinates &coor)const - отвечает что находится в интересующей ячейке
	
	Character search(const std::string key)const - выдаёт первого персонажа отвечающему на ключ (all, enemies, allies)
	
	std::vector<Character> look(const std::string key)const - выдаёт всех персонажей
	
	Coordinates in_direction(const Coordinates &coor)const - выдаёт клетку по направлению движения к coor
	
	bool .board.assert_coordinates(const Coordinates &coor)const - метод самого поля, проверяет существования клетки
	
Этой информации более чем достаточно, чтобы задать весьма сложное поведение!

5.4) Чтобы применить стратегию нужно:

	а) В классе Engine добавить переменную вашего класса, проинициализировать её game_state
	б) В методе choose_strategy() аналогично добавить if(character.name.compare("Ваше имя")==0) с return ваша переменная
	в) В одной из команд A.team или B.team указать хотябы 1го персонажа с соответсвующим именем


Часть VI. Проблемы, запуски и баги

6.1) Для Windows в Core.h нужно DELIMITER '/' за менить на '\'

6.2) Сущесвует папочка Log в которой текстовые файлики с запясими запусков, если что-то пошло не так посмотрите туда.

6.3) Чтобы программа запустилась введите в консоли start, чтобы выйти - exit. Пока из-за бага 2ой раз старт вводить не стоит
	