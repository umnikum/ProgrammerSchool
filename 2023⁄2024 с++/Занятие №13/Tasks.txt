 Задания:

Beginner lvl:

1) По очереди вводятся 3 цифры, вывести полученное из них число.
Рекомендации:
-Не усложнять первую версию программы, до успешного прохождения проверки
-Использовать обычный int для цифр и результата
-После прохождения проверки подумать как вести себя с передним нулём.

2) Вводится рациональное число, определить является ли его целая часть чётной.
Рекомендации:
-Использовать static_cast<int>(переменная) чтобы получить целую часть
-Использовать переменная % делитель, чтобы получить остаток от деления

3) Считать набор целых чисел из файла numbers.in, вывести на экран в обратном порядке.
Перед набором стоит количество элементов в наборе.
Рекомендации:
-Использовать #include <fstream>, класс std::ifstream
-Предполагать что чисел меньше 100, использовать обычный массив тип[100];

Intermediate lvl:

1) Написать функцию считывания вектора целых чисел произвольной длинны из файла.
Программа должна запускать консоль, принимать имена файлов, выводя их содержимое на экран,
или команду exit, чтобы завершиться.
Рекомендации:
-Использовать do{}while

2) Посчитать количество поялений заданного c консоли строчного ключа в файле text.in.
Требования:
-Обязательное считывание всего файла, getline() до !ifs.eof()
-Учитывать повторные появления, например: ключ-мама, в тексте-мамама 2 появления МАМАма, маМАМА
-Разрешено не учитвывать регистр, т.е. А != а
-Файл считывается только один раз, а не на каждый ключ

3) В файле matrix.in находится размер N квадрантного двумерного массива целых чисел,
и его элементы. Найти наибольший элемент среди элементов лежащих выше диагонали,
наименьший из элементов лежащих ниже диагонали. Среди них вывести наибольший по модулю.
Требования:
-Массив динамический, размер может быть практически любым!
-Успешно проходятся тесты
Рекомендации:
-Использовать одномерный массив, создать функцию перерасчёта одномерного индекса из двумерного
-Использовать либо std::vector<int>, либо new int[N](не забыть delete [] переменная; в конце программы)

Advanced lvl:

1) В стране сущесвтует N городов, соединённых друг с другом железными дорогами. В файле roads.in
хранится N и квадратный симметричный двумерный массив неотрицательных целых чисел обозначающих стоимость поездки
между городами с номером строки и столбца. В файле task.in хранится неотрицательное целое число cash -
балланс пользователя и пара чисел A - номер города в котором пользователь находится, B - номер города
в котором пользователь должен оказаться.
	После запуска программы, пользователю выводится задание и список номеров городов, в которые он может
поехать с соответсвующими стоимостями в скобках. Пользователь вводит номер города в который он собирается
отправиться, если у него хватает денег, то он путешествует и ему выводятся балланс и новые возможные поездки.
Если пользователь застрял, т.е. у него не хватает денег ни на один маршрут, либо достиг цели, программа
вывоит результат и завершается.
Требования:
-Пользователь не обязан вводить правильную информацию, учесть ошибки ввода внутри типа переменной

2) Реализовать карточную колоду. В колоде 52 карты(без джокера), каждая имеет номинал и масть(suit).
Существуют 4 масти: червы(Hearts), пики(Spades), буби(Diamonds) и крести(Clubs). Каждая имеет 13
различных номиналов, цифры 2-10 и особые: валет(Jack), дама(Queen), король(King) и туз(Ace). Каждая
номинальная карта оценивается своим номером, туз(Ace) - 11 очков, картинки(J,Q,K) - 10 очков.
Часть А:
-По строке обозначений распознавать карты: JS(Jack of Spades) 10H(10 of Hearts) AC(Ace of Clubs)
-Сравнивать карты по масти, номиналу и порядку Jack < Queen, хотя обе карты 10 очков
-Считать сумму очков в наборе(std::vector<Card>)
Часть B:
-Сортировать набор по масти, номиналу
-Считать количество мастей в наборе
-Считать максимальное количество карт с одинаковым номиналом в наборе
Часть C:
-Создать наблон комбинации карт проверяющий увовлетворяет ли ему набор.
-Создать проверку руки из 5 карт вытянутых из колоды на наличие комбинаций "Холдема" и вывести наибольшую
-Создать механизм сравнения комбинаций

3) Стратегия*
